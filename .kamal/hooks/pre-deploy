#!/usr/bin/env bash
set -euo pipefail

# Kamal pre-deploy hook: graceful worker drain
#
# Checks if the GhostHands worker has active jobs and waits for it to
# become idle before allowing Kamal to proceed with the deploy.
#
# The worker exposes /worker/health on port 3101 with a deploy_safe field.
# This hook polls that endpoint every 2s for up to 120s (matching drain_timeout).
#
# Exit 0 = proceed with deploy
# Exit 1 = abort deploy (worker stuck busy)

WORKER_PORT="${GH_WORKER_PORT:-3101}"
WORKER_URL="http://localhost:${WORKER_PORT}/worker/health"
MAX_WAIT=120
INTERVAL=2
ATTEMPTS=$((MAX_WAIT / INTERVAL))

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

log()  { echo -e "${GREEN}[pre-deploy]${NC} $*"; }
warn() { echo -e "${YELLOW}[pre-deploy]${NC} $*"; }
err()  { echo -e "${RED}[pre-deploy]${NC} $*" >&2; }

# Request graceful drain first (tells worker to stop polling for new jobs)
log "Requesting worker drain on port ${WORKER_PORT}..."
curl -sf -X POST "http://localhost:${WORKER_PORT}/worker/drain" > /dev/null 2>&1 || true

for i in $(seq 1 "$ATTEMPTS"); do
  status=$(curl -sf "$WORKER_URL" 2>/dev/null) || {
    # Worker endpoint not reachable — might be an older image or already stopped
    warn "Worker health endpoint not reachable (attempt $i) — assuming safe to deploy"
    exit 0
  }

  safe=$(echo "$status" | grep -o '"deploy_safe":[a-z]*' | cut -d: -f2)

  if [ "$safe" = "true" ]; then
    log "Worker is idle — safe to deploy (checked in $((i * INTERVAL))s)"
    exit 0
  fi

  elapsed=$((i * INTERVAL))
  active_jobs=$(echo "$status" | grep -o '"active_jobs":[0-9]*' | cut -d: -f2)
  warn "Worker busy (${active_jobs:-?} active jobs), waiting... ${elapsed}s/${MAX_WAIT}s"
  sleep "$INTERVAL"
done

err "Worker still busy after ${MAX_WAIT}s — aborting deploy"
err "Run 'kamal deploy' again when the worker is idle, or use --skip-hooks to force"
exit 1
