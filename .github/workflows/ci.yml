name: CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main, staging]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  BUN_VERSION: "1.2"
  NODE_VERSION: "20"

jobs:
  # ─── Checks (run on every push & PR) ─────────────────────────

  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run build

  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run test:unit

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [typecheck]
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run test:integration
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          SUPABASE_PUBLISHABLE_KEY: ${{ secrets.SUPABASE_PUBLISHABLE_KEY }}
          SUPABASE_DIRECT_URL: ${{ secrets.SUPABASE_DIRECT_URL }}
          GH_SERVICE_SECRET: ${{ secrets.GH_SERVICE_SECRET }}
          GH_ENCRYPTION_KEY: ${{ secrets.GH_ENCRYPTION_KEY }}

  # ─── Docker build (main + staging branches) ────────────────────
  # Staging: tags as staging-<sha> + mutable staging
  # Main:    tags as <sha> + latest

  docker:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    needs: [typecheck, test-unit]
    if: github.event_name == 'push'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      environment: ${{ steps.meta.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute image metadata
        id: meta
        run: |
          if [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "image_tag=staging-${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "environment=staging" >> "$GITHUB_OUTPUT"
            echo "tag_latest=false" >> "$GITHUB_OUTPUT"
            echo "tag_staging=true" >> "$GITHUB_OUTPUT"
          else
            echo "image_tag=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "environment=production" >> "$GITHUB_OUTPUT"
            echo "tag_latest=true" >> "$GITHUB_OUTPUT"
            echo "tag_staging=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.meta.outputs.image_tag }}
          TAG_LATEST: ${{ steps.meta.outputs.tag_latest }}
          TAG_STAGING: ${{ steps.meta.outputs.tag_staging }}
        run: |
          TAGS="-t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          if [ "$TAG_LATEST" = "true" ]; then
            TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:latest"
          fi
          if [ "$TAG_STAGING" = "true" ]; then
            TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:staging"
          fi

          docker build \
            --build-arg COMMIT_SHA=${{ github.sha }} \
            --build-arg BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
            --build-arg IMAGE_TAG=$IMAGE_TAG \
            $TAGS \
            .

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          if [ "$TAG_LATEST" = "true" ]; then
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          fi
          if [ "$TAG_STAGING" = "true" ]; then
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging
          fi

  # ─── Deploy via Kamal (replaces deploy-to-asg SSH script) ────
  # Discovers running ASG instances, generates destination config
  # with their IPs, then deploys via Kamal with deploy locking,
  # rolling deploys (boot.limit=1), and pre-deploy drain hook.
  #
  # Manual fallback: scripts/deploy-manual.sh (SSH + docker compose)

  deploy-kamal:
    name: Deploy via Kamal
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.event_name == 'push'
    environment: ${{ needs.docker.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Write SSH key and config
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SANDBOX_SSH_KEY }}" > ~/.ssh/valet-worker.pem
          chmod 600 ~/.ssh/valet-worker.pem
          cat >> ~/.ssh/config <<SSH_EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            IdentityFile ~/.ssh/valet-worker.pem
          SSH_EOF
          chmod 600 ~/.ssh/config

      - name: Install Kamal
        run: gem install kamal

      - name: Write Kamal secrets
        run: |
          mkdir -p .kamal
          echo "KAMAL_REGISTRY_PASSWORD=$(aws ecr get-login-password --region ${{ secrets.AWS_REGION }})" > .kamal/secrets

      - name: Discover ASG hosts and generate destination config
        id: discover
        env:
          AWS_ASG_NAME: ghosthands-worker-asg
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ENVIRONMENT: ${{ needs.docker.outputs.environment }}
        run: |
          echo "Discovering running ASG instances..."
          HOSTS=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters \
              "Name=tag:aws:autoscaling:groupName,Values=${AWS_ASG_NAME}" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].PublicIpAddress' \
            --output text)

          if [ -z "$HOSTS" ]; then
            echo "::error::No running instances found in ASG: ${AWS_ASG_NAME}"
            exit 1
          fi

          # Convert tab-separated IPs to YAML list
          HOST_COUNT=0
          HOST_YAML=""
          for ip in $HOSTS; do
            HOST_YAML="${HOST_YAML}      - ${ip}"$'\n'
            HOST_COUNT=$((HOST_COUNT + 1))
          done

          echo "Found ${HOST_COUNT} running ASG instance(s)"
          echo "host_count=${HOST_COUNT}" >> "$GITHUB_OUTPUT"

          # Write destination-specific config that overrides default hosts
          mkdir -p config
          DEST_FILE="config/deploy.${ENVIRONMENT}.yml"
          {
            echo "# Auto-generated by CI — overrides default hosts with ASG instances"
            echo "servers:"
            echo "  web:"
            echo "    hosts:"
            for ip in $HOSTS; do
              echo "      - ${ip}"
            done
            echo "  worker:"
            echo "    hosts:"
            for ip in $HOSTS; do
              echo "      - ${ip}"
            done
          } > "${DEST_FILE}"

          echo "Generated ${DEST_FILE}:"
          cat "${DEST_FILE}"

      - name: Deploy via Kamal
        env:
          IMAGE_TAG: ${{ needs.docker.outputs.image_tag }}
          ENVIRONMENT: ${{ needs.docker.outputs.environment }}
        run: |
          echo "Deploying ${IMAGE_TAG} to ${ENVIRONMENT} via Kamal..."
          kamal deploy \
            --destination "${ENVIRONMENT}" \
            --version "${IMAGE_TAG}"

      - name: Verify deployment
        env:
          AWS_ASG_NAME: ghosthands-worker-asg
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Verifying health on all ASG instances..."
          HOSTS=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters \
              "Name=tag:aws:autoscaling:groupName,Values=${AWS_ASG_NAME}" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].PublicIpAddress' \
            --output text)

          FAILED=0
          for ip in $HOSTS; do
            if curl -sf "http://${ip}:3100/health" > /dev/null 2>&1; then
              echo "  ${ip}: healthy"
            else
              echo "  ${ip}: UNHEALTHY"
              FAILED=$((FAILED + 1))
            fi
          done

          if [ "$FAILED" -gt 0 ]; then
            echo "::warning::${FAILED} instance(s) failed health check after deploy"
          fi

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/valet-worker.pem

  # ─── Deploy: Staging (notify VALET after Kamal deploy) ────────

  deploy-staging:
    name: Deploy Staging
    runs-on: ubuntu-latest
    needs: [docker, deploy-kamal]
    if: github.ref == 'refs/heads/staging' && github.event_name == 'push'
    environment: staging
    steps:
      - name: Notify VALET (staging)
        env:
          VALET_DEPLOY_WEBHOOK_URL: ${{ secrets.VALET_DEPLOY_WEBHOOK_URL }}
          VALET_DEPLOY_WEBHOOK_SECRET: ${{ secrets.VALET_DEPLOY_WEBHOOK_SECRET }}
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ needs.docker.outputs.image_tag }}
          BRANCH: ${{ github.ref_name }}
        run: |
          if [ -z "$VALET_DEPLOY_WEBHOOK_URL" ]; then
            echo "::warning::VALET_DEPLOY_WEBHOOK_URL not configured for staging. Skipping."
            echo "Image ready: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
            exit 0
          fi

          PAYLOAD=$(jq -cn \
            --arg event "ghosthands.deploy_ready" \
            --arg image "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" \
            --arg image_tag "${IMAGE_TAG}" \
            --arg image_latest "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_message "$(echo "${{ github.event.head_commit.message }}" | head -1)" \
            --arg branch "${BRANCH}" \
            --arg environment "staging" \
            --arg repository "${{ github.repository }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{event: $event, image: $image, image_tag: $image_tag, image_latest: $image_latest, commit_sha: $commit_sha, commit_message: $commit_message, branch: $branch, environment: $environment, repository: $repository, run_id: $run_id, run_url: $run_url, timestamp: $timestamp}')

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$VALET_DEPLOY_WEBHOOK_SECRET" | awk '{print $2}')

          echo "Notifying VALET staging: ${IMAGE_TAG}"

          HTTP_STATUS=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" \
            -X POST "$VALET_DEPLOY_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-GH-Webhook-Signature: sha256=${SIGNATURE}" \
            -H "X-GH-Event: deploy_ready" \
            -H "X-GH-Environment: staging" \
            --max-time 30 \
            -d "$PAYLOAD")

          echo "VALET responded with HTTP ${HTTP_STATUS}"
          cat /tmp/webhook_response.txt

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "Staging deploy notification sent."
          else
            echo "::warning::VALET staging webhook returned HTTP ${HTTP_STATUS}."
          fi

  # ─── Rebuild Kasm image on Kasm server (SSH) ──────────────────
  # Builds Dockerfile.kasm directly on the Kasm EC2 server.
  # The image is ~8GB (full desktop + GH worker), so we build locally
  # on the server rather than pushing through ECR.

  deploy-kasm:
    name: Rebuild Kasm Image
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.event_name == 'push'
    environment: ${{ needs.docker.outputs.environment }}
    steps:
      - name: Write SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SANDBOX_SSH_KEY }}" > ~/.ssh/valet-worker.pem
          chmod 600 ~/.ssh/valet-worker.pem

      - name: Rebuild Kasm image on server
        env:
          KASM_SERVER_IP: ${{ secrets.KASM_SERVER_IP }}
          SSH_USER: ubuntu
        run: |
          if [ -z "$KASM_SERVER_IP" ]; then
            echo "::warning::KASM_SERVER_IP not configured. Skipping Kasm image rebuild."
            exit 0
          fi

          SSH_OPTS="-i ~/.ssh/valet-worker.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10"

          echo "Rebuilding Kasm image on ${KASM_SERVER_IP}..."

          ssh $SSH_OPTS ${SSH_USER}@${KASM_SERVER_IP} bash -s << 'REMOTE_SCRIPT'
          set -e
          cd /opt/GHOST-HANDS

          # Pull latest code
          sudo git config --global --add safe.directory /opt/GHOST-HANDS
          sudo git fetch origin staging
          sudo git reset --hard origin/staging

          # Build the Kasm image
          echo "Building ghosthands-kasm:latest..."
          sudo docker build -f Dockerfile.kasm -t ghosthands-kasm:latest . 2>&1 | tail -5

          # Prune dangling images to save disk
          sudo docker image prune -f > /dev/null 2>&1 || true

          echo "Kasm image rebuilt successfully."
          sudo docker images ghosthands-kasm --format '{{.ID}} {{.Tag}} {{.CreatedAt}}'
          REMOTE_SCRIPT

          echo "Kasm image rebuild complete on ${KASM_SERVER_IP}."

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/valet-worker.pem

  # ─── Deploy: Production ───────────────────────────────────────
  # Only triggers on main branch pushes, after Kamal deploy

  deploy-production:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: [docker, deploy-kamal]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - name: Notify VALET (production)
        env:
          VALET_DEPLOY_WEBHOOK_URL: ${{ secrets.VALET_DEPLOY_WEBHOOK_URL }}
          VALET_DEPLOY_WEBHOOK_SECRET: ${{ secrets.VALET_DEPLOY_WEBHOOK_SECRET }}
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ needs.docker.outputs.image_tag }}
        run: |
          if [ -z "$VALET_DEPLOY_WEBHOOK_URL" ]; then
            echo "::warning::VALET_DEPLOY_WEBHOOK_URL not configured for production. Skipping."
            echo "Image ready: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
            exit 0
          fi

          PAYLOAD=$(jq -cn \
            --arg event "ghosthands.deploy_ready" \
            --arg image "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" \
            --arg image_tag "${IMAGE_TAG}" \
            --arg image_latest "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_message "$(echo "${{ github.event.head_commit.message }}" | head -1)" \
            --arg branch "main" \
            --arg environment "production" \
            --arg repository "${{ github.repository }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{event: $event, image: $image, image_tag: $image_tag, image_latest: $image_latest, commit_sha: $commit_sha, commit_message: $commit_message, branch: $branch, environment: $environment, repository: $repository, run_id: $run_id, run_url: $run_url, timestamp: $timestamp}')

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$VALET_DEPLOY_WEBHOOK_SECRET" | awk '{print $2}')

          echo "Notifying VALET production: ${IMAGE_TAG}"

          HTTP_STATUS=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" \
            -X POST "$VALET_DEPLOY_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-GH-Webhook-Signature: sha256=${SIGNATURE}" \
            -H "X-GH-Event: deploy_ready" \
            -H "X-GH-Environment: production" \
            --max-time 30 \
            -d "$PAYLOAD")

          echo "VALET responded with HTTP ${HTTP_STATUS}"
          cat /tmp/webhook_response.txt

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "Production deploy notification sent."
          else
            echo "::warning::VALET production webhook returned HTTP ${HTTP_STATUS}."
          fi
