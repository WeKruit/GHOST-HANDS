name: CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main, staging]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  BUN_VERSION: "1.2"
  NODE_VERSION: "20"

jobs:
  # ─── Checks (run on every push & PR) ─────────────────────────

  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run build

  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run test:unit

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [typecheck]
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
      - run: bun install --frozen-lockfile
      - run: bun run test:integration
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SECRET_KEY: ${{ secrets.SUPABASE_SECRET_KEY }}
          SUPABASE_PUBLISHABLE_KEY: ${{ secrets.SUPABASE_PUBLISHABLE_KEY }}
          SUPABASE_DIRECT_URL: ${{ secrets.SUPABASE_DIRECT_URL }}
          GH_SERVICE_SECRET: ${{ secrets.GH_SERVICE_SECRET }}
          GH_ENCRYPTION_KEY: ${{ secrets.GH_ENCRYPTION_KEY }}

  # ─── Docker build (main + staging branches) ────────────────────
  # Staging: tags as staging-<sha> + mutable staging
  # Main:    tags as <sha> + latest

  docker:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    needs: [typecheck, test-unit]
    if: github.event_name == 'push'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      environment: ${{ steps.meta.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute image metadata
        id: meta
        run: |
          if [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "image_tag=staging-${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "environment=staging" >> "$GITHUB_OUTPUT"
            echo "tag_latest=false" >> "$GITHUB_OUTPUT"
            echo "tag_staging=true" >> "$GITHUB_OUTPUT"
          else
            echo "image_tag=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "environment=production" >> "$GITHUB_OUTPUT"
            echo "tag_latest=true" >> "$GITHUB_OUTPUT"
            echo "tag_staging=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.meta.outputs.image_tag }}
          TAG_LATEST: ${{ steps.meta.outputs.tag_latest }}
          TAG_STAGING: ${{ steps.meta.outputs.tag_staging }}
        run: |
          TAGS="-t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          if [ "$TAG_LATEST" = "true" ]; then
            TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:latest"
          fi
          if [ "$TAG_STAGING" = "true" ]; then
            TAGS="$TAGS -t $ECR_REGISTRY/$ECR_REPOSITORY:staging"
          fi

          docker build \
            --build-arg COMMIT_SHA=${{ github.sha }} \
            --build-arg BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
            --build-arg IMAGE_TAG=$IMAGE_TAG \
            $TAGS \
            .

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          if [ "$TAG_LATEST" = "true" ]; then
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          fi
          if [ "$TAG_STAGING" = "true" ]; then
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging
          fi

  # ─── Deploy: Staging (notify VALET after ASG is updated) ─────

  deploy-staging:
    name: Deploy Staging
    runs-on: ubuntu-latest
    needs: [docker, deploy-asg]
    if: github.event_name == 'push'
    environment: staging
    steps:
      - name: Notify VALET (staging)
        env:
          VALET_DEPLOY_WEBHOOK_URL: ${{ secrets.VALET_DEPLOY_WEBHOOK_URL }}
          VALET_DEPLOY_WEBHOOK_SECRET: ${{ secrets.VALET_DEPLOY_WEBHOOK_SECRET }}
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ needs.docker.outputs.image_tag }}
          BRANCH: ${{ github.ref_name }}
        run: |
          if [ -z "$VALET_DEPLOY_WEBHOOK_URL" ]; then
            echo "::warning::VALET_DEPLOY_WEBHOOK_URL not configured for staging. Skipping."
            echo "Image ready: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
            exit 0
          fi

          PAYLOAD=$(jq -cn \
            --arg event "ghosthands.deploy_ready" \
            --arg image "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" \
            --arg image_tag "${IMAGE_TAG}" \
            --arg image_latest "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_message "$(echo "${{ github.event.head_commit.message }}" | head -1)" \
            --arg branch "${BRANCH}" \
            --arg environment "staging" \
            --arg repository "${{ github.repository }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{event: $event, image: $image, image_tag: $image_tag, image_latest: $image_latest, commit_sha: $commit_sha, commit_message: $commit_message, branch: $branch, environment: $environment, repository: $repository, run_id: $run_id, run_url: $run_url, timestamp: $timestamp}')

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$VALET_DEPLOY_WEBHOOK_SECRET" | awk '{print $2}')

          echo "Notifying VALET staging: ${IMAGE_TAG}"

          HTTP_STATUS=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" \
            -X POST "$VALET_DEPLOY_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-GH-Webhook-Signature: sha256=${SIGNATURE}" \
            -H "X-GH-Event: deploy_ready" \
            -H "X-GH-Environment: staging" \
            --max-time 30 \
            -d "$PAYLOAD")

          echo "VALET responded with HTTP ${HTTP_STATUS}"
          cat /tmp/webhook_response.txt

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "Staging deploy notification sent."
          else
            echo "::warning::VALET staging webhook returned HTTP ${HTTP_STATUS}."
          fi

  # ─── Deploy to ASG instances (SSH) ────────────────────────────
  # FIRST: SSH to each running ASG instance and pull/restart the
  # new image. VALET notification happens after this succeeds.

  deploy-asg:
    name: Deploy to ASG Fleet (disabled — using Kamal via ATM)
    runs-on: ubuntu-latest
    needs: [docker]
    if: false  # Disabled: Kamal deploys via ATM replace docker-compose ASG deploy
    environment: ${{ needs.docker.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Write SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SANDBOX_SSH_KEY }}" > ~/.ssh/wekruit-atm-server.pem
          chmod 600 ~/.ssh/wekruit-atm-server.pem

      - name: Deploy to ASG instances
        env:
          AWS_ASG_NAME: ghosthands-worker-asg
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          SSH_USER: ubuntu
        run: |
          chmod +x scripts/deploy-to-asg.sh
          bash scripts/deploy-to-asg.sh "${{ needs.docker.outputs.image_tag }}"

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/wekruit-atm-server.pem

  # ─── Deploy: Production ───────────────────────────────────────
  # Only triggers on main branch pushes, after ASG is updated

  deploy-production:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - name: Notify VALET (production)
        env:
          VALET_DEPLOY_WEBHOOK_URL: ${{ secrets.VALET_DEPLOY_WEBHOOK_URL }}
          VALET_DEPLOY_WEBHOOK_SECRET: ${{ secrets.VALET_DEPLOY_WEBHOOK_SECRET }}
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ needs.docker.outputs.image_tag }}
        run: |
          if [ -z "$VALET_DEPLOY_WEBHOOK_URL" ]; then
            echo "::warning::VALET_DEPLOY_WEBHOOK_URL not configured for production. Skipping."
            echo "Image ready: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
            exit 0
          fi

          PAYLOAD=$(jq -cn \
            --arg event "ghosthands.deploy_ready" \
            --arg image "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" \
            --arg image_tag "${IMAGE_TAG}" \
            --arg image_latest "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_message "$(echo "${{ github.event.head_commit.message }}" | head -1)" \
            --arg branch "main" \
            --arg environment "production" \
            --arg repository "${{ github.repository }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{event: $event, image: $image, image_tag: $image_tag, image_latest: $image_latest, commit_sha: $commit_sha, commit_message: $commit_message, branch: $branch, environment: $environment, repository: $repository, run_id: $run_id, run_url: $run_url, timestamp: $timestamp}')

          SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$VALET_DEPLOY_WEBHOOK_SECRET" | awk '{print $2}')

          echo "Notifying VALET production: ${IMAGE_TAG}"

          HTTP_STATUS=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" \
            -X POST "$VALET_DEPLOY_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "X-GH-Webhook-Signature: sha256=${SIGNATURE}" \
            -H "X-GH-Event: deploy_ready" \
            -H "X-GH-Environment: production" \
            --max-time 30 \
            -d "$PAYLOAD")

          echo "VALET responded with HTTP ${HTTP_STATUS}"
          cat /tmp/webhook_response.txt

          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
            echo "Production deploy notification sent."
          else
            echo "::warning::VALET production webhook returned HTTP ${HTTP_STATUS}."
          fi

